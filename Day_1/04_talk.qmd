# Creating spatial weights objects {#sec-sd-w}

```{r pl_io0, echo=FALSE, results="hide"}
io_dir <- "Input_output"
if (!dir.exists(io_dir)) io_dir <- paste0("../", io_dir)
```

```{r echo=FALSE}
load(file = paste0(io_dir, "/talk3.RData"))
```


Chapter 14 of @pebesma+bivand:23 provides a fairly up-to-date account of how one may construct `"nb"` neighbour objects, and from these `"listw"` weights objects. In the following chapters, these objects will be used extensively in modelling, and will often be referred to as spatial weights matrices. While their description in terms of linear algebra as matrices is reasonable, their representation as dense $n$ by $n$ matrices is much less reasonable, as in most cases, only a very few elements of such a matrix are non-zero. This means that sparse representations are certainly preferable in terms of storage and efficiency, and repeated multiplication by zero is simply wasteful. `"nb"` neighbour objects, and `"listw"` weights objects are sparse representations, where the `"nb"` object records which objects $j$ are neighbours of $i$ for each $i$, and `"listw"` objects add in the weights assigned to each such 
$i$-$j$ relationship. 

We will use the `spdep` package to construct neighbour objects for the 123 Pomeranian municipalities. Since we have the boundaries of the municipalities, we can see which municipalities share boundary segments, known as rook contiguity; we add identifiers to the output object, now only to show it can be done, but later for use in out-of-sample prediction among other uses:

```{r pom_sw1, size="footnotesize"}
library(sf)
library(spdep)
(pom6a |> poly2nb(queen=FALSE,
 row.names=pom6a$TERYT) -> pom_rook_nb)
```

If we slacken our definition of contiguity to simply sharing one boundary point, to queen contiguity, we see that the problems detected here of two no-neighbour municipalities and seven disjoint subgraphs remain:

```{r pom_sw2, size="footnotesize"}
(pom6a |> poly2nb(queen=TRUE,
 row.names=pom6a$TERYT) -> pom_queen_nb)
```

One possible reason for such problems is that boundaries provided by public agencies are accurate enough for their purposes, but where shared boundary points are not exactly identical. If we pass a very small distance, here one-hundredth of a millimetre, as a snap distance, the problems are resolved:

```{r pom_sw3, size="footnotesize"}
(pom6a |> poly2nb(queen=FALSE, row.names=pom6a$TERYT,
 snap=0.00001) -> pom_rook_nb)
(pom6a |> poly2nb(queen=TRUE, row.names=pom6a$TERYT,
 snap=0.00001) -> pom_queen_nb)
```

We can also see that in this case the rook and queen definitions lead to the same neighbour object; differences are more often seen in US tracts or counties with grid-like boundaries where four entities meet at a single point.

By definition, contiguity neighbours, like distance threshold neighbours are symmetric, that is if $i$ is a neighbour of $j$, $j$ must be a neighbour of $i$. This is only rarely the case when defining neighbours as the $k$-nearest points. Asymmetric neigbours lead to directed graphs, which can also be handled, but which need subsequent numerical special treatment. There may be substantive reasons for choosing asymmetric neighbours, but it is probably a good idea to spell out the reasons clearly.

It is important to establish whether no-neighbour entities really have no neighbours because in matrix terms they lead to columns and rows with only zero values. Some methods become poorly defined if observations "drop out" of analysis in this way. For similar reasons, the detection of disjoint subgraphs, that is parts of the neighbour object that are unconnected from other parts of the object, jeopardises the outcome of modelling, as spatial processes cannot travel across the whole graph. The graph we have found now can be plotted, using `st_point_on_surface` internally to provide points to represent the polygons:

```{r pom_sw4, size="footnotesize"}
#| label: pom_sw4
#| fig-cap: Queen neighbour object, Pomeranian municipalities, 2022
geom <- st_geometry(pom6a) 
plot(geom, border="grey")
plot(pom_queen_nb, geom, add=TRUE)
```

When choosing the five nearest neighbours as the neighbour criterion, with distance measured to suit the coordinate reference system of the point geometries, the outcome is most often asymmetric:

```{r pom_sw5, size="footnotesize"}
(geom |> st_point_on_surface() |> knearneigh(k=5) |>
 knn2nb(row.names=pom6a$TERYT) -> pom_k5_nb)
```
```{r pom_sw6, size="footnotesize"}
#| label: pom_sw6
#| fig-cap: Five nearest neighbour object, Pomeranian municipalities, 2022
plot(geom, border="grey")
plot(pom_k5_nb, geom, add=TRUE)
```

As Figure @pom_sw6a shows, open coastal water is crossed by links between neighbours defined in this way. For the point support Gdańsk take-away outlets and five nearest neighbours, asymmetry is expected, but as with many distance measures, this case does raise the question of whether to measure distance in a distance metric or perhaps a time metric, because crossing a busy street takes more time than walking or cycling along a street:

```{r gd_sw1, size="footnotesize"}
(gd_takeaways|> knearneigh(k=5) |>
 knn2nb(row.names=gd_takeaways$osm_id) -> gd_k5_nb)
```
```{r gd_sw1a, size="footnotesize"}
gd_k5_nb |> nb2lines(coords=st_geometry(gd_takeaways)
 ) -> gd_k5_nb_sf
```

As Figure @gd_sw2a shows, the outlets are tightly clustered into disjoint subgraphs, but on more careful consideration, the outlets are multi-function, also serving drop-in customers. An outlet only offering take-away service might be located best near peak demand conditioned by the cost of property rental and transport accessibility, but most seem to sell to multiple markets: take-away, eat in restaurant, and delivery to customer. Maybe some compete on price, but cuisine may be a differentiator as well. 

```{r gd_sw2a, size="footnotesize", eval=!knitr::is_latex_output()}
#| label: gd_sw2a
#| fig-cap: Five nearest neighbour object, Gdańsk take-away outlets, OpenStreetMap
library(mapview)
mapview(gd_takeaways) + mapview(gd_k5_nb_sf, color="red4")
```
```{r gd_sw2b, echo=FALSE, results="as.is", eval=knitr::is_latex_output(), warning=FALSE}
#| label: gd_sw2b
#| fig-cap: Screen dump of interactive map of five nearest neighbour object, Gdańsk take-away outlets, OpenStreetMap
img <- try(knitr::include_graphics("Images/sd/gd_tkwy.png"), silent=TRUE)
if (inherits(img, "try-error")) knitr::include_graphics("../Images/sd/gd_tkwy.png")
```

Having shown some methods for constructing neighbour objects, we can briefly mention the assignment of weights to the neighbour links:

```{r pom_sw7, size="footnotesize"}
pom_queen_nb |> nb2listw(style="W") -> pom_queen_lw
summary(pom_queen_lw)
```

The output of the `summary` method shows the same details as for the `nb` object, adding a tabulation by neighbour count, the weights style `"W"`, meaning that the weights are standardised so that the sum of weights for each observation is unity:

```{r pom_sw8, size="footnotesize"}
pom_queen_lw$weights |> sapply(sum) |> unique()
```

In some modelling settings, the `"B"` binary zero-one style is preferred, and there are a number of alternative ways of specifying weights. Finally, if the neighbour object contains no-neighbour entities, the `zero.policy` argument to `nb2listw` may be used to indicate that zero weights are acceptable - the obvious alternatives are to exclude such entities, or to add neighbour links so that all entities have neigbours.


# Spatial data {#sec-sd}

In section @sec-why-special, we showed why spatial data should be treated as "special" until it is shown that they do not require the application of specific methods to handle combinations of spatial autocorrelation, spatial scale and spatial heterogeneity. We did not there develop the concepts and tools needed for understanding and handling spatial data before analysis, or the presentation of results from spatial econometric models in spatial form. This treatment builds on @pebesma+bivand:23 chapters 1--6 and the R packages used there, but will also to some extent indicate where that software usage is matched in Python and elsewhere, for example @reyetal:23; for a comparative description, see @bivand:22. If the reader is unfamiliar with data of this kind, they may benefit from @lovelaceetal:19.

## Spatial data basics {#sec-sd-basics}

Spatial data are observations on variables, be they categorical, ordinal or continuous. The observations are associated with a position in space, where space is often represented as (sets of) coordinate tuplets on a map; spatial data are also found in bioinformatics and medical imaging, but here we are concerned with geographical spatial data. 

Geographical spatial data take two forms: spatial vectors and spatial rasters. Spatial vector objects are most often represented by geometries of sets of pairs of coordinates known as eastings and northings, or longitude and latitude, forming points, lines or polygons; three-dimensional spatial vectors are not often used but may be provided by data sources. Spatial raster objects are regular square or rectangular grids of cells, most like digital images. Spatial rasters are fixed to a spatial point of origin and the locations of cells can be found from the point of origin by stepping out from the origin cell and summing the distances crossing intervening calls measured by the size or resolution of the cells. Rasters have one or more bands, and may also be termed spatial data cubes, structured by two or three spatial dimensions (three if height/depth is included) and a time dimension in addition to bands containing sensor measurements.

While spatial raster objects include attribute data - observations on variables taken at the location of each cell, spatial vector objects do not have to do so. Observations on variables of interest are linked to geometries through a common key or identifier. The key linking the observations with the spatial vector geometries may often be a standard code published and updated by a government statistical office. Not infrequently, the data are acquired or downloaded including the key, and the geometries of the spatial objects are acquired or downloaded separately, to be merged by the observation keys afterwards. Noting the timestamp specifying the validity of geometries and keys is always sensible, as both keys and geometries change over time. We will return to the representation of time in spatial panel objects, where the geometries are invariant but variables of interest are observed over successive time periods.

For the present, spatial data will be taken as-is; we will return to reading and writing spatial data from and to files in Section @sec-sd-io. The comprehensive R archive network (CRAN) provides software packages and short summaries called task views listing packages useful for particular tasks. The Spatial task view (https://cran.r-project.org/view=Spatial) lists packages accessing or providing specific data sources of interest. Here we will use three such packages: `chilemapas` with administrative boundaries for Chile, and `rgugik` for Poland, `elevatr` for spatial raster elevation data, and `osmdata` for OpenStreetMap information. The representation of the spatial vector data is handled by the `sf` package: 

```{r chile1, size="footnotesize"}
Sys.setenv("PROJ_NETWORK"="ON")
library(sf)
```
```{r chile1a, size="footnotesize", message=FALSE}
library(chilemapas)
```
```{r chile1b, size="footnotesize"}
mapa_comunas |> data.frame() |> 
  st_as_sf(sf_column_name="geometry") -> mc_sf
mc_sf
```

The `mapa_comunas` data object stored in the `chilemapas` package is represented as a tibble and an `sf` object. Because most model fitting objects expect data as a `data.frame` not a `tbl` also known as a tibble, we coerce to `data.frame` and re-construct the `sf` object using the `sf::st_as_sf` method for `data.frame` objects. The disparity between `data.frame` and `tbl` objects is that when a single column of a `data.frame` is selected with the `[` method, it becomes a vector by default, but the `[` method on a single column of a `tbl` object returns a `tbl` by default. The `geometry` column is an `sfc` object, a list column of `sfg` objects, where `sfg` means "Simple Feature" geometry.

```{r chile2, size="footnotesize"}
st_geometry(mc_sf)
```

The geometry column contains 345 multi-polygon objects, containing the boundaries of Chilean municipalities in 2017, clipped to the coastline. They are multi-polygons because at least some municipalities are composed of island and mainland parts. The short summary printed here also states that the geometries have a geodetic coordinate reference system (CRS), here specified as SIRGAS 2000. We return to coordinate reference systems in the next section @sec-sd-crs, but note that area calculation is conducted on the specified ellipsoid using the `s2` by default, not on the plane. 

Let us find the area of Región del Maule, region `"07"`, of which Taule is the capital city, using the region key column in the `sf` object named `mc_sf`. First we subset the municipalities to the desired region, then union the municipalities in Región del Maule before finding the area of the region as a whole. 

```{r chile3, size="footnotesize"}
mc_sf |> subset(subset=codigo_region == "07") -> maule_sf
maule_sf |> st_union() |> st_area() |> units::set_units("km2")
```

The result agrees adequately with 30,296.1 square kilometres given by [Wikipedia](https://en.wikipedia.org/wiki/Regions_of_Chile), as the details of administrative boundaries and hence the computed area are compromises between detail and the size of the data object stored in the package. By default the results of length or area calculations for spherical coordinates are returned by `s2` in metres or square metres, so we convert to square kilometres.

`sf` objects pay attention to the support of variables, whether they may be classed as constant, aggregate, or identity. Constant variables are constant across the whole area of a polygon, for example a land use category. Aggregate variables may be counts, rates based on counts, or densities of counts by polygon area. Identity variables uniquely identify the geometries. In the case of the Región del Maule data set, no definitions have so far been provided, so when we change support from polygon to point by computing the spherical centroid, a warning is given [see @pebesma+bivand:23, pp. 49--52]. `st_agr` returns the current state of the factor (categorical object) for the non-geometry variables included in the `sf` object:

```{r chile4, size="footnotesize"}
st_agr(maule_sf)
maule_sf |> st_centroid() -> maule_sf_pt1
```

We can avoid the warning by taking the centroid of the geometries alone, of the `sfc` object rather than the `sf` object:

```{r chile5, size="footnotesize"}
maule_sf |> st_geometry() |> st_centroid() -> maule_sfc_pt2
```

Alternatively, since there are few non-geometry columns in the data set, we can assign the appropriate values to them, so that since the change of support does not change the meaning of the variables, no warning is given:

```{r chile6, size="footnotesize"}
maule_sf |> 
  st_set_agr(c(codigo_comuna="identity",
               codigo_provincia="identity", 
               codigo_region="constant")
            ) -> maule_sf_agr
st_agr(maule_sf_agr)
maule_sf_agr |> st_centroid() -> maule_sf_pt3
```

The three remaining packages download spatial data from public sources rather than pre-packaging them for use. `elevatr` can be used to download global elevation data as a spatial raster; until version 1 of the package is released, it returns a `"RasterLayer"` as defined in the legacy `raster` package, but from 1.0 will return a `"SpatRaster"` defined in the `terra` package. Here we specify our area of interest by passing the `sf` spatial vector object for Región del Maule, and clip the output to the boundary of the region, setting negative values to missing:

```{r chile7, size="footnotesize"}
library(elevatr)
library(terra)
maule_sf |>  get_elev_raster(z = 7,
 clip = "locations", neg_to_na = TRUE) |> 
 rast() -> maule_elev
maule_elev
```

The raster has one layer (band), with a square (geodetic) grid with a resolution of about 0.005 degrees, 18.03 arc seconds in both dimensions, 371 rows and 493 columns. 

Let us now access OpenStreetMap data using `osmdata` [@padghametal:17], first subsetting to the city of Talca, the capital of Región del Maule. To set up a query, we need to build an OpenStreetMap Overpass query using a bounding box of our area of interest. Since it can be difficult to know what kinds of data have been contributed, we add the `"names"` feature, pulling in everything in the rectangle defined in degrees of longitude and latitude - obviously the top and bottom of the rectangle are actually curves, because the rectangle is on the surface of an ellipsoid. Having created the query `talca_q`, we can extract the data for all features with names:

```{r chile8, size="footnotesize"}
maule_sf |> subset(subset = codigo_comuna=="07101") -> talca_sf
library(osmdata)
talca_sf |> st_bbox() |> opq() |>
 add_osm_feature(key = "names") -> talca_q
```

```{r chile8a, size="footnotesize", eval=FALSE}
talca_q |> osmdata_sf() -> talca_osm_sf
```
```{r chile8b, size="footnotesize", echo=FALSE, warning=FALSE}
talca_osm_sf <- try(base::readRDS("Datasets/sd/talca_osm_sf.rds"), silent=TRUE)
if (inherits(talca_osm_sf, "try-error")) talca_osm_sf <- base::readRDS("../Datasets/sd/talca_osm_sf.rds")
```
```{r chile8c, size="footnotesize"}
talca_osm_sf
```

The output object is a list of components, some of which are `sf` objects. If we take the point objects, we can attempt to subset to those said to offer take-away service, that is those for which the `takeaway` variable is not coded `NA` - missing. 

```{r chile9, size="footnotesize"}
talca_osm_sf$osm_points -> talca_pts
talca_pts |> subset(subset = !is.na(takeaway), 
 select = c(osm_id, name, amenity, cuisine,
  takeaway, geometry)) -> talca_takeaways
talca_takeaways
```

There only appear to be 11 such establishments, but perhaps these are the ones whose locations grateful clients (or ambitious proprietors) have contributed to OpenStreetMap.

The `rgugik` package [@dyba+nowosad:21] does not bundle the municipality boundaries of Poland as `chilemapas` did for Chile, but downloads them from the Polish Head Office of Geodesy and Cartography (GUGIK) online. The object returned from a query to the boundaries of the Gdańsk county administrative unit is an `sf` object with a single variable, the identification key.

```{r pl1, size="footnotesize"}
library(rgugik)
gd_sf <- borders_get(county = "Gdańsk")
gd_sf
```

Again, we can use the `sf` object to access elevation data, here returned with about 88 metre resolution, as the input object has a projected coordinate reference system:

```{r pl2, size="footnotesize"}
gd_sf |>  get_elev_raster(z = 9,
 clip = "locations", neg_to_na = TRUE) |> rast() -> gd_elev
gd_elev
```

As we just observed, `gd_sf` has a projected coordinate reference system, so needs to be transformed to a geodetic coordinate reference system before the creation of an Openpass query, here for `"amenity"` features:

```{r pl3, size="footnotesize"}
gd_sf |> st_transform(crs = "OGC:CRS84") |> st_bbox() |>
 opq() |> add_osm_feature(key = "amenity") -> gd_q
```
```{r pl3a, size="footnotesize", eval=FALSE}
gd_q |> osmdata_sf() -> gd_osm_sf
```
```{r pl3b, size="footnotesize", echo=FALSE, warning=FALSE}
gd_osm_sf <- try(base::readRDS("Datasets/sd/gd_osm_sf.rds"), silent=TRUE)
if (inherits(gd_osm_sf, "try-error")) gd_osm_sf <- base::readRDS("../Datasets/sd/gd_osm_sf.rds")
```
```{r pl3c, size="footnotesize"}
gd_osm_sf
```

Once again we extract the locations of registered take-away outlets, of which many more seem to have been contributed to OpenStreetMap than in the case of the bounding box surrounding the city of Talca:

```{r pl4, size="footnotesize"}
gd_osm_sf$osm_points -> gd_pts
gd_pts |> subset(subset = !is.na(takeaway),
 select = c(osm_id, name, amenity, cuisine,
  takeaway, geometry)) -> gd_takeaways
gd_takeaways
```


## Coordinate reference systems {#sec-sd-crs}

Since 2019, the representation of coordinate reference systems (CRS) have stabilised in the well-known text format known as WKT2-2019, which is an international standard. The representation supports both two and three dimensional structures, and as implemented in open geospatial software (PROJ) uses definitions stored in a regularly updated database bundled with the software. The database also contains tables defining transformations between CRS, now often based on open access transformation grid files downloaded on-the-fly if required. In parts of the world subject to rapid tectonic movement (the old city centre of Talca, Chile was badly damaged by an earthquake in 2010), CRS change frequently if more by centimetres than by metres. 

```{r chile-crs1, size="footnotesize"}
st_crs(talca_sf)
```

The definition used for stored objects in the `chilemapas` package is the geographical CRS in decimal degrees called `"SIRGAS 2000"` based on the `"GRS 1980"` ellipsoid - geodetic reference system of 1980. The provided data have as is often the case swapped axes compared to the CRS definition. Most geographical information systems keep to $x$, $y$, that is easting, northing or longitude, latitude axis order. Before version 1.0, `elevatr` reverts to the legacy PROJ4 string representation seen in the summaries above.

`osmdata` and OpenStreetMap appear to assume that all modern geographical coordinate reference systems use `"EPSG:4326"` as is said to apply to consumer global positioning systems (GPS) devices. This is somewhat accurate, but there is no fixed definition. The definition is usually updated locally for each major tectonic plate, so the WKT2-2019 representation of the CRS used here is as a datum ensemble, with at best two metre accuracy, often worse, as we are noe fourty years on from where the tectonic plates were when `"WGS 84` was agreed in 1984. Some surveyors have argued that all coordinate tuples should be timestamped, in order to permit the tracking of the movement of points across the earth's surface and their vertical change as well. 

```{r chile-crs2, size="footnotesize"}
st_crs(talca_takeaways)
```

So while the `"SIRGAS 2000"` object and the `"WGS 84` refer approximately to the same representation, some `sf` predicates and operations on geometries may see them as differing, as for example checking that the Talca take-aways found in the bounding box do lie within the municipality boundaries:

```{r chile-crs3, size="footnotesize"}
try(st_within(talca_takeaways, talca_sf))
```

Since we know that both are based on the`"GRS 1980"` ellipsoid, we can overwrite the CRS of the OpenStreetMap take-away outlets location output to bring it into agreement with `"SIRGAS 2000"`, resulting in finding that all the outlets all lie within the municipality boundaries:

```{r chile-crs4, size="footnotesize"}
talca_sf |> st_crs() -> sirgas2000
talca_takeaways |> st_set_crs(sirgas2000) |>
 st_within(talca_sf) |> unlist() |> as.logical()
```

@alvescostaetal:23 document current status for the development of SIRGAS, and helpfully show how an increase in ground GPS/GNSS (Global Navigation Satellite Systems from all providers) station density helps track terrestrial movement, which in parts of Chile exceeds 20mm per year. While the movement of the earth's crust is one source of inaccuracy, another is measurement error, and yet another computational error from repeated use of trigonometrical functions and approximated transformation coefficients. A lack of clarity in defining CRS can lead to the wrong assignation of for example points to polygons. 

The Universal Transverse Mercator projection (zone 19 south) is often used for central Chile, and this specific version uses the same `"SIRGAS 2000"` datum as the input data objects from `chilemapas`:

```{r chile-crs5, size="footnotesize"}
st_crs("EPSG:31979")
```

If we check to see which candidate coordinate operations are available, we see that in fact projection accuracy is as good as possible, because the datum definitions of the two CRS are the same:

```{r chile-crs6, size="footnotesize"}
sf_proj_network(TRUE)
sf_proj_pipelines("EPSG:4674", "EPSG:31979")
```

If we replace the target CRS with `"SIRGAS-Chile 2021 UTM 19S"`, `sf_proj_pipelines` still only finds one candidate, but because no datum transformation from `"SIRGAS 2000"` to `"SIRGAS-Chile 2021"` is found in the database, we must accept unknown ballpark accuracy:

```{r chile-crs6a, size="footnotesize"}
sf_proj_pipelines("EPSG:4674", "EPSG:20049")
```

Many national and international mapping agencies have provided open access transformation grids that PROJ can use on-the-fly (https://cdn.proj.org/), but neither Chile not SIRGAS have contributed any such grid so far. Grids are more accurate than three or seven parameter transformations because they allow local crustal deformations to be applied, rather than averaged over the whole area of application. Accuracy is now much more important as GPS/GNSS has become established in navigation, precision farming, construction, etc.

Let us repeat the measurement of the area of Región del Maule after projection to `"UTM 19S"`

```{r chile-crs7, size="footnotesize"}
maule_sf |> st_union() |> st_transform(crs = "EPSG:31979") |>
 st_area() |> units::set_units("km2")
```

The area is now more than 16 square kilometres greater than the area from Wikipedia, and the area calculated by `s2` on the surface of the earth. All projections distort the rounded surface of the earth by squeezing the centre of the area of interest and stretching the edges to force it into planar form, so depending on the statutory regulations, all measured areas are approximate in one way or another.

Let us now move to the CRS of the boundary of the county of Gdańsk:

```{r pl-crs1, size="footnotesize"}
st_crs(gd_sf)
```

Poland currently uses the European Terrestrial Reference Frame (ETRF) and lies on a tectonic plate with little deformation activity, although the plate itself is moving up to 20mm a year. The projection `"ETRF2000-PL / CS92"` was adopted following the dissolution of the Warsaw Pact - mapping everywhere is driven at base by the needs of military operations.

The CRS of the take-away outlets is as for Talca:

```{r pl-crs2, size="footnotesize"}
st_crs(gd_takeaways)
```

and the transformation pipeline from `"ETRF2000-PL / CS92"` to `"WGS 84"` has an accuracy of 1 metre:

```{r pl-crs3, size="footnotesize"}
sf_proj_pipelines("EPSG:2180", "EPSG:4326")
```

Since none of these projections/transformations have required datum transformation, let us use the example of `"OSGB36 / British National Grid"` to `"WGS 84"`. We can see that the `"Ordnance Survey of Great Britain 1936"` datum uses a different ellipsoid: `"Airy 1830"` from `"GRS 1980"`:

```{r crs-osgb1, size="footnotesize"}
st_crs("EPSG:27700")
```

If we then query the database to find the most accurate transformation with enabled access to transformation grids, we can achieve 1 metre:

```{r crs-osgb2, size="footnotesize"}
sf_proj_pipelines("EPSG:27700", "EPSG:4326")
```

The parts of the grid file `uk_os_OSTN15_NTv2_OSGBtoETRS.tif` needed for the data in question can be downloaded automatically on-the-fly if PROJ network access is enabled, and cached locally for any software using PROJ for handling CRS; the grid file offsets are shown in Figure 2.4, page 25 of @pebesma+bivand:23.

```{r pl_io0, echo=FALSE, results="hide"}
io_dir <- "Input_output"
if (!dir.exists(io_dir)) io_dir <- paste0("../", io_dir)
```

```{r echo=FALSE}
save(list = ls(), file = paste0(io_dir, "/talk2.RData"))
```

